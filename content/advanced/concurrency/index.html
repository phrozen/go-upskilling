<h2>Concurrency</h2>
<h3>Go routines</h3>
<p>Go Routines are lightweight threads that run in the same address space since this mean that the access to memory have to be synchronized.</p>
<p>To run a new routine it just need to use the keyword go</p>
<pre><code class="language-go">go function()
</code></pre>
<h3>Channels</h3>
<p>Using channels is the easy way to communicate between routines since they allow routines to syncronize without explicit locks or conditions by blocking the channel until the sender or receiver is ready.
The channels type is chan and they have to be initialized before can be used.</p>
<pre><code class="language-go">c := make(chan int)
</code></pre>
<p>They also have a reserved operator for channels <code>&lt;-</code></p>
<pre><code class="language-go">import &quot;fmt&quot;

func factorial(n int,c chan int){
    fact := 1:
    for i:=1; i&lt;=n ; i++{
        fact = fact*i
    }
    c&lt;-fact
}

func main(){
    c := make(chan, int)
    go factorial(5,c)
    fmt.Println(&lt;-c)
}
</code></pre>
<p>Information is transmitted in or out the channel depending on the position of the channel and the arrow operator</p>
<h3>Buffers</h3>
<p>Channels can have a buffered size that block the channel for send when is full or for receiving when is empty.</p>
<pre><code class="language-go">c := make(chan int, 5)
</code></pre>
<p>Writing to a buffered channel will block if it is full.</p>
<h3>Range and close</h3>
<p>A sender can send a signal to indicate that the channel will not be receiving any more updates. This can be done by the function close(c).</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;math/rand&quot;
    &quot;runtime&quot;
    &quot;sync&quot;
    &quot;time&quot;
)

func init() {
    fmt.Printf(&quot;Using %d workers...\n&quot;, runtime.NumCPU())
    rand.Seed(time.Now().UnixNano())
}

//This funciton will &quot;process&quot; the data by random wauting from 1 to 5 secodns
func process(name int, data chan int, wg *sync.WaitGroup) {
    for i := range data {
        elapsed := (time.Duration(rand.Intn(5)) + 1) * time.Second
        time.Sleep(elapsed)
        fmt.Printf(&quot;Worker %d) Processed data: %d in %d[ms]\n&quot;, name, i, elapsed/1000000)
    }
    wg.Done()
}

func main() {
    //This WaitGroup will help us to wait for all the threads
    wg := &amp;sync.WaitGroup{}
    data := make(chan int)

    for i := 0; i &lt; runtime.NumCPU(); i++ {
        //We increase the number of go routine that we need to wait
        wg.Add(1)
        //We create a new rutine that will process data
        go process(i+1, data, wg)
 }

    for i := 0; i &lt; 64; i++ {
        data &lt;- i + 1
    }

    close(data)
    wg.wait()
}

</code></pre>
<p>In this example we create a wait group, this will help to keep track of the routines, this strcut has two methods, <code>add(int)</code> and <code>wait()</code> we add 1 for every routine called then we waited for the routines to finish.</p>
<p>To check if a channel has been closet it can be done by adding a variable when assigning a value, similar to checking for a key existing in a map.</p>
<pre><code class="language-go"> v, ok := &lt;-c
</code></pre>
<p>ok is false if there are no more values to receive and the channel is closed.</p>
<h3>Select</h3>
<p>The select keyword can be used to wait until a case can be executed</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
)

func selector(values chan int, runes chan rune, wg *sync.WaitGroup) {
    sum := 0
    myString := &quot;&quot;
    for {
        select {
        case value := &lt;-values:
            sum += value
            fmt.Printf(&quot;Sum value: %d\n&quot;, sum)
            if sum == 20 {
                defer wg.Done()
                return
            }
        case letter := &lt;-runes:
            myString += string(letter)
            fmt.Printf(&quot;String value: %s\n&quot;, myString)
        }
    }
}

func main() {
    values := make(chan int)
    runes := make(chan rune)
    letters := []rune(&quot;abcdfghijklm&quot;)
    wg := &amp;sync.WaitGroup{}
    wg.Add(1)
    go selector(values, runes, wg)
    values &lt;- 5
    values &lt;- 5
    values &lt;- 5
    for i := 0; i &lt; len(letters); i++ {
        runes &lt;- letters[i]
    }
    values &lt;- 5
    wg.Wait()
}
</code></pre>
<h3>Locks</h3>
<p>Go standard library offers a way to provided a easy way to avoid conflicts in routines. this can me done with sync.Mutex that to methods: <code>Lock()</code>, <code>Unlock()</code>, they allow only one routine to have access to the block of code. This can be used to create atomic operations and avoid race conditions.</p>
<p>Since this locks <strong><em>block the resource for reading and writing</em></strong>, the use of a <strong>RWMutex</strong> is recommended, since they allow to block the channel for reading or writing or for both. This can also be found in sync.RWMutex and have the methods <code>Lock()</code>, <code>Unlock()</code> for writing and <code>RLock()</code> and <code>RUnlock()</code> for reading.</p>
