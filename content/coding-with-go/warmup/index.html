<h2>Warming up</h2>
<p>Once that we have the basics concepts of the language we can start coding, to warm up we are going to solve some basic problems.</p>
<h3>Tree preorder transversal</h3>
<p>The first thing that we need to do is create the structure for the tree.</p>
<pre><code class="language-go">type tree struct{
    value num
    left *tree
    right *tree
}
</code></pre>
<p>Once that we the struct for the tree, we can implement the algorithm for it, for the sake of this exercise we will do it first preorder recursive and then preorder without recursion.</p>
<h4>Recursive</h4>
<p>Creating Recursive solution is pretty simple since the recursion in go is the same as in other languages:</p>
<pre><code class="language-go">func preorderTransversalRecursion(root *tree) {
    if root == nil {
        return
    }
    fmt.Println(root.value)
    preorderTransversalRecursion(root.left)
    preorderTransversalRecursion(root.right)
}
</code></pre>
<h4>Non recursive</h4>
<p>To create a non recursive solution we need a queue or a list were to store the nodes to visit.</p>
<pre><code class="language-go">func preorderTransversalNoRecursion(root *tree) {
  //We create a new list to store the nodes to visit
	l := list.New()
  //Since the list is waiting a empty interface we can pass our struct without problems
	l.PushBack(root)
	for l.Len() &gt; 0 {
    //This will return an *Element
		tmp := l.Front()
    //We do a little of reflection and cast back from Element
		tmpNode := tmp.Value.(*tree)
		l.Remove(tmp)
		fmt.Println(tmpNode.value)
		if tmpNode.right != nil {
			l.PushFront(tmpNode.right)
		}
		if tmpNode.left != nil {
			l.PushFront(tmpNode.left)
		}
	}
}
</code></pre>
<h3>Two numbers in array can sum a number</h3>
<p>This problem can be solved with a map so, lets use one.</p>
<pre><code class="language-go">func canSum(a []int, t int) bool {
	m := make(map[int]bool)
  // we can check all elements in the array usnig a range
    for _, i := range a {
        if _, ok := m[t-i]; ok {
            return true
        }
        m[i] = true
    }
    return false
}
</code></pre>
